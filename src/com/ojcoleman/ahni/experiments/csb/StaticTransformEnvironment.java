package com.ojcoleman.ahni.experiments.csb;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.Vector;

import javax.imageio.ImageIO;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.util.MultidimensionalCounter;
import org.apache.log4j.Logger;
import org.jgapcustomised.Allele;
import org.jgapcustomised.Chromosome;

import com.anji.integration.Activator;
import com.anji.integration.AnjiActivator;
import com.anji.neat.ConnectionAllele;
import com.anji.neat.NeatConfiguration;
import com.anji.neat.NeuronAllele;
import com.anji.neat.NeuronType;
import com.anji.nn.AnjiNet;
import com.anji.nn.CacheNeuronConnection;
import com.anji.nn.Connection;
import com.anji.nn.Neuron;
import com.anji.nn.NeuronConnection;
import com.anji.nn.activationfunction.ActivationFunctionFactory;
import com.ojcoleman.ahni.hyperneat.Properties;
import com.ojcoleman.ahni.util.ArrayUtil;
import com.ojcoleman.ahni.util.Range;

/**
 * <p>
 * An environment which uses arbitrary functions to transform signals to and from the environment state. One function
 * transforms the output vector from the agent into changes to the environments state and another is used to transform
 * the current state into an input vector for the agent (ie it generates the agents perception of the current
 * environment state). The input transform is used to generate a delta vector which represents a (relatively small)
 * change in the environment state. This function is generated such that it is possible to create a positive and
 * negative value for each output from the function corresponding to each dimension of the environment state. Thus, via
 * this transform, the agent can move around within the Cartesian space represented by the environment state space.
 * </p>
 * <p>
 * Note that the input and output vector sizes do not need to match the size of the vector representing the environment
 * state. The transforms may be highly non-linear. The transform functions are implemented with {@link AnjiNet} neural
 * networks in a feed-forward function. The functions are composed of randomly selected and connected nodes which
 * represent a single mathematical function, such as Sigmoid, multiply, inverse, absolute, etc. Increasing the
 * difficulty of the environment increases the number of nodes in the network and/or the in-degree of connections for
 * each node.
 * </p>
 * <p>
 * The reward signal, which is a function of the Euclidean distance from the current environment state to the goal
 * state, is provided directly to the agent.
 * </p>
 * <p>
 * Environments can optionally have (hyper-)spherical obstacles added at random locations (increasing the environment
 * difficulty increases the number of obstacles). The agent cannot directly perceive the obstacles. If the environment
 * size (dimensionality) is 2 then the images generated by RLContinuousStateBased will include the obstacle locations.
 * </p>
 */
public class StaticTransformEnvironment extends SimpleNavigationEnvironment {
	private static Logger logger = Logger.getLogger(SimpleNavigationEnvironment.class);

	/**
	 * The size of the output vector. Defaults to fitness.function.rlcss.size + 1 (ie environment state size plus a
	 * reinforcement signal). The last value in the output vector is always the reinforcement signal and isn't affected
	 * by the state to output transform function.
	 */
	public static final String OUTPUT_SIZE = "fitness.function.rlcss.size.output";
	/**
	 * The size of the input vector. Defaults to fitness.function.rlcss.size.
	 */
	public static final String INPUT_SIZE = "fitness.function.rlcss.size.input";
	/**
	 * The function types that may be used in the input and output transforms.
	 */
	public final static String TRANSFORM_FUNCTIONS = "fitness.function.rlcss.transform.functions";
	/**
	 * Specify whether a transform function is used for the input. Default is true.
	 */
	public final static String TRANSFORM_INPUT_ENABLE = "fitness.function.rlcss.transform.input";
	/**
	 * Specify whether a transform function is used for the output. Default is true.
	 */
	public final static String TRANSFORM_OUTPUT_ENABLE = "fitness.function.rlcss.transform.output";

	protected int inputSize;
	protected int outputSize;
	protected boolean enableInputTransform;
	protected boolean enableOutputTransform;
	protected String[] transformFuncTypes;
	protected Random random;
	protected int funcCount = 4;
	protected int inDegree = 2;
	protected Range outputTransformInputRange = new Range(-1, 1);

	/**
	 * Transforms input from the agent to changes in the current environment state.
	 */
	protected Transform inputTransform;

	/**
	 * Transforms the current environment state to input for the agent (ie the agents perception of the environment).
	 */
	protected Transform outputTransform;

	@Override
	public void init(Properties props) {
		super.init(props);

		inputSize = props.getIntProperty(INPUT_SIZE, size);
		outputSize = props.getIntProperty(OUTPUT_SIZE, size + 1);
		enableInputTransform = props.getBooleanProperty(TRANSFORM_INPUT_ENABLE, true);
		enableOutputTransform = props.getBooleanProperty(TRANSFORM_OUTPUT_ENABLE, true);
		transformFuncTypes = props.getProperty(TRANSFORM_FUNCTIONS).split(",");
		for (int i = 0; i < transformFuncTypes.length; i++) {
			transformFuncTypes[i] = transformFuncTypes[i].trim().toLowerCase();
		}
	}

	@Override
	public void setUp(int id) {
		super.setUp(id);
		random = props.getConfig().getRandomGenerator();

		if (enableInputTransform) {
			inputTransform = new Transform(TransformType.INPUT, inputSize, size, funcCount, inDegree, new Range(-1, 1));
		}
		if (enableOutputTransform) {
			outputTransform = new Transform(TransformType.OUTPUT, size, outputSize - 1, funcCount, inDegree, outputTransformInputRange);
		}

		double path = findPath();
		// multiply path length by 2 because when checking to make sure that the input transform allows producing all
		// possible combinations of directions we only check for values that would allow moving at half the maximum
		// speed.
		requiredSteps = (int) Math.ceil((path * 2.2) / maxStepSize);
		if (props.getIntProperty(RLContinuousStateBased.TRIAL_COUNT) == 1) {
			// The agent needs to try different directions to see which is the right one in the same trial
			// allow some extra time for this.
			requiredSteps += 2 * size * size;
		}
	}

	@Override
	public double updateStateAndOutput(ArrayRealVector state, double[] input, double[] output) {
		if (inputTransform != null) {
			double[] inputT = inputTransform.transform(input);
			// Output from transform is always in range [0, 1], scale to [-1, 1].
			for (int i = 0; i < inputT.length; i++) {
				inputT[i] = inputT[i] * 2 - 1;
			}
			return super.updateStateAndOutput(state, inputT, output);
		} else {
			return super.updateStateAndOutput(state, input, output);
		}
	}

	@Override
	public double getOutputForState(ArrayRealVector state, double[] output) {
		// Update output given new state.
		ArrayRealVector stateT = state;
		if (outputTransform != null) {
			double[] s = ArrayUtil.scaleFromUnit(state.toArray(), outputTransformInputRange);
			stateT = new ArrayRealVector(outputTransform.transform(s));
		}
		System.arraycopy(stateT.getDataRef(), 0, output, 0, stateT.getDimension());
		output[output.length - 1] = getRewardForState(state);
		return getPerformanceForState(state);
	}

	@Override
	public boolean increaseDifficultyPossible() {
		return false;
	}

	@Override
	public void increaseDifficulty() {
		funcCount++;
		inDegree++;
		logger.info("Transform function count is now " + funcCount + ", in-degree is now " + inDegree);
	}

	@Override
	public int getOutputSize() {
		return outputSize;
	}

	@Override
	public int getInputSize() {
		return inputSize;
	}

	@Override
	public String toString() {
		return ">>> " + super.toString() + "\n\n>>> Input transform:\n" + inputTransform + "\n\n>>> Output transform:\n" + outputTransform;
	}

	/**
	 * {@inheritDoc} Renders the input and output transforms of the environment.
	 */
	@Override
	public void logToImage(String baseFileName, int imageSize) {
		super.logToImage(baseFileName, imageSize);
		if (inputTransform != null) {
			inputTransform.render(baseFileName + ".transform.input", imageSize);
		}
		if (outputTransform != null) {
			outputTransform.render(baseFileName + ".transform.output", imageSize);
		}
	}

	protected class Transform {
		private TransformType type;
		private Activator function;
		private Range[] outputValueRanges;
		private Range inputValueRange;

		public Transform(TransformType type, int numInputs, int numOutputs, int numHidden, int inDegree, Range inputValueRange) {
			this.type = type;
			this.inputValueRange = inputValueRange;
			outputValueRanges = new Range[numOutputs];
			for (int i = 0; i < numOutputs; i++) {
				outputValueRanges[i] = new Range();
			}
			int tries = 0;
			do {
				// System.out.println("newTransform(" + numInputs + ", " + numOutputs + ", " + numHidden + ", " +
				// inDegree + ")");
				function = newTransform(numInputs, numOutputs, numHidden, inDegree);
				tries++;
			} while (!isViable());
			logger.info("Took " + tries + " to create " + type + " transform.");
		}

		public synchronized double[] transform(double[] input) {
			return transform(input, type.scaleOutput());
		}

		public double[] transform(double[] input, boolean scaleOutput) {
			double[] output = function.next(input);
			if (scaleOutput) {
				for (int i = 0; i < output.length; i++) {
					output[i] = outputValueRanges[i].translateToUnit(output[i]);
					// Scaler may be based on observed output range so may not be quite right, so truncate if necessary.
					if (output[i] < 0)
						output[i] = 0;
					else if (output[i] > 1)
						output[i] = 1;
				}
			}
			return output;
		}

		private Activator newTransform(int numInputs, int numOutputs, int numHidden, int inDegree) {
			ArrayList<Neuron> inputNeurons = new ArrayList<Neuron>(numInputs);
			ArrayList<Neuron> outputNeurons = new ArrayList<Neuron>(numOutputs);
			ArrayList<Neuron> allNeurons = new ArrayList<Neuron>(numInputs + numHidden + numOutputs);

			for (int i = 0; i < numInputs; i++) {
				Neuron n = newNeuron("linear", 0);
				inputNeurons.add(n);
				allNeurons.add(n);
			}
			for (int i = 0; i < numHidden; i++) {
				allNeurons.add(newNeuron("random", random.nextDouble() * 2 - 1));
			}
			for (int i = 0; i < numOutputs; i++) {
				Neuron n = newNeuron("linear", random.nextDouble() * 2 - 1);
				outputNeurons.add(n);
				allNeurons.add(n);
			}

			// Add connections.
			ArrayList<Integer> srcIndices = new ArrayList<Integer>();
			for (int src = 0; src < numInputs; src++) {
				srcIndices.add(src);
			}
			for (int trg = numInputs; trg < allNeurons.size(); trg++) {
				Collections.shuffle(srcIndices, random);
				for (int d = 0; d < Math.min(inDegree, srcIndices.size()); d++) {
					NeuronConnection c = new NeuronConnection(allNeurons.get(srcIndices.get(d)), random.nextGaussian());
					// NeuronConnection c = new NeuronConnection(allNeurons.get(srcIndices.get(d)),
					// random.nextDouble()*2-1);
					allNeurons.get(trg).addIncomingConnection(c);
				}

				// Add hidden nodes to list of allowable source nodes.
				if (trg < numInputs + numHidden) {
					srcIndices.add(trg);

					// While the number of potential source neurons is greater than the in-degree,
					// remove an input node from the list of potential source nodes to make it more
					// likely that hidden nodes will be selected, to increase the non-linearity.
					/*
					 * for (int i = 0; srcIndices.size() > inDegree && i < srcIndices.size(); i++) { // If this is an
					 * input neuron. if (srcIndices.get(i) < numInputs) { srcIndices.remove(i); } }
					 */
				}
			}

			AnjiNet nn = new AnjiNet(allNeurons, inputNeurons, outputNeurons, new ArrayList<CacheNeuronConnection>(), null);
			return new AnjiActivator(nn, 1);
		}

		private Neuron newNeuron(String func, double bias) {
			if (func == "random")
				return new Neuron(ActivationFunctionFactory.valueOf(transformFuncTypes[random.nextInt(transformFuncTypes.length)]), bias);
			return new Neuron(ActivationFunctionFactory.valueOf(func), bias);
		}

		/**
		 * Ensures that the function is an (approximate) one-to-one mapping and, if the transform type requires it, that
		 * all output sign combinations exist.
		 */
		private boolean isViable() {
			int granularity = 11; // Step size is 0.1
			double stepSize = 1d / (granularity - 1); // Step size in unit-cube.
			MultidimensionalCounter mc = new MultidimensionalCounter(ArrayUtil.newArray(function.getInputCount(), granularity));

			int totalInputPoints = mc.getSize(); // granularity ^ transform.getInputCount()
			double[][] outputs = new double[totalInputPoints][];
			double[] input = new double[function.getInputCount()];
			double[] observedMinOutputValue = ArrayUtil.newArray(function.getOutputCount(), Double.POSITIVE_INFINITY);
			double[] observedMaxOutputValue = ArrayUtil.newArray(function.getOutputCount(), Double.NEGATIVE_INFINITY);

			// For each input permutation.
			MultidimensionalCounter.Iterator mci = mc.iterator();
			while (mci.hasNext()) {
				int idx = mci.next();
				for (int d = 0; d < function.getInputCount(); d++) {
					input[d] = inputValueRange.translateFromUnit(mci.getCount(d) * stepSize);
				}
				outputs[idx] = function.next(input);
				for (int d = 0; d < outputs[idx].length; d++) {
					if (outputs[idx][d] < observedMinOutputValue[d])
						observedMinOutputValue[d] = outputs[idx][d];
					if (outputs[idx][d] > observedMaxOutputValue[d])
						observedMaxOutputValue[d] = outputs[idx][d];
				}
				// System.out.println(Arrays.toString(input) + " => " + Arrays.toString(outputs[idx]));
			}

			// Determine output value ranges for scaling output values to unit-cube.
			if (function.getMinResponse() < -100 || function.getMaxResponse() > 100) {
				for (int d = 0; d < function.getOutputCount(); d++) {
					if (observedMaxOutputValue[d] - observedMinOutputValue[d] < 0.001) {
						observedMaxOutputValue[d] = observedMinOutputValue[d] + 0.001;
					}
					outputValueRanges[d].set(observedMinOutputValue[d], observedMaxOutputValue[d]);
					// System.out.println("range: " + outputValueRanges[d]);
				}
			} else {
				for (int d = 0; d < function.getOutputCount(); d++) {
					outputValueRanges[d].set(function.getMinResponse(), function.getMaxResponse());
				}
			}
			// Scale output vectors to lie within unit-cube and check that all output sign combinations exist if the
			// transform type requires it.
			boolean[] signCombo = new boolean[2 << (function.getOutputCount() - 1)];
			int signComboCoveredCount = 0;
			for (int i = 0; i < outputs.length; i++) {
				for (int d = 0; d < outputs[i].length; d++) {
					outputs[i][d] = outputValueRanges[d].translateToUnit(outputs[i][d]);
				}
				// System.out.println(Arrays.toString(outputs[i]));

				// If we need to check that all output sign combinations exist and not all combinations have been
				// covered yet.
				if (type.ensureAllOutputSignCombinationsExist() && signComboCoveredCount < signCombo.length) {
					String combo = ""; // Create binary string representing combo.
					boolean tooMiddling = false;
					for (int d = 0; d < outputs[i].length; d++) {
						double o = outputs[i][d];
						if (o > 0.25 && o < 0.75) {
							tooMiddling = true;
							break;
						}
						combo += outputs[i][d] >= 0.5 ? "1" : "0";
					}
					// If the max or min values for one of the outputs is too small then ignore it for
					// the purposes of determining whether the combination it represents is covered.
					if (tooMiddling) {
						continue;
					}
					int comboIndex = Integer.parseInt(combo, 2);
					if (!signCombo[comboIndex]) {
						signCombo[comboIndex] = true;
						signComboCoveredCount++;
					}
				}
			}
			// System.out.println("  totalTestPoints: " + totalInputPoints);
			// System.out.println("  signCombo: " + Arrays.toString(signCombo));

			if (type.ensureAllOutputSignCombinationsExist() && signComboCoveredCount < signCombo.length)
				return false;

			// Determine how many output points are too close to any other point.
			int tooCloseCount = 0;
			// equivOutputNeighbourDistance is the distance apart points would have to be in the output (hyper-)cube in
			// order to fit totalInputPoints points in when arranged in a grid.
			double equivOutputNeighbourDistance = 1.0 / (Math.pow(totalInputPoints, 1.0 / function.getOutputCount()) - 1);

			for (int i = 0; i < outputs.length; i++) {
				for (int j = i + 1; j < outputs.length; j++) {
					// If two output points are closer than 10% of the equivalent distance between neighbouring points
					// in the input space.
					if (ArrayUtil.distance(outputs[i], outputs[j]) < equivOutputNeighbourDistance * 0.1) {
						tooCloseCount++;
						break;
					}
				}
			}
			double fracTooClose = (double) tooCloseCount / totalInputPoints;

			// System.out.println("  equivOutputNeighbourDistance: " + equivOutputNeighbourDistance);
			// System.out.println("  tooCloseCount: " + tooCloseCount);
			// System.out.println("  fracTooClose: " + fracTooClose);

			// If less than 5% of tested input point pairs map too close to each other in the output space
			// then the transform is considered to be an approximate one-to-one mapping.
			return fracTooClose < 0.05;
		}

		// Render the transform function as a 2D image (if possible).
		private boolean alreadyRendered = false;

		public void render(String fileName, int imageSize) {
			synchronized (this) {
				if (alreadyRendered)
					return;
				alreadyRendered = true;
			}
			if (function.getOutputCount() == 2 && function.getInputCount() <= 3) {
				BufferedImage image = new BufferedImage(imageSize, imageSize, BufferedImage.TYPE_3BYTE_BGR);
				Graphics2D g = image.createGraphics();
				g.setColor(Color.WHITE);
				g.fillRect(0, 0, imageSize, imageSize);
				// Set granularity of input sampling so that we sample a number
				// of points equal to the number of pixels in the image.
				int granularity = (int) Math.round(Math.pow(imageSize * imageSize, 1.0 / function.getInputCount()));
				double stepSize = 1d / (granularity - 1); // Step size in unit-cube.

				// For each input value permutation.
				MultidimensionalCounter mc = new MultidimensionalCounter(ArrayUtil.newArray(function.getInputCount(), granularity));
				MultidimensionalCounter.Iterator mci = mc.iterator();
				double[] input = new double[function.getInputCount()];
				while (mci.hasNext()) {
					mci.next();
					// Set input values to function.
					for (int d = 0; d < function.getInputCount(); d++) {
						input[d] = inputValueRange.translateFromUnit(mci.getCount(d) * stepSize);
					}
					// Get output from function given input values.
					double[] output = transform(input, true);

					// Use output values (of which there are only two) to determine coordinates.
					int x = (int) (output[0] * (imageSize - 1));
					int y = (int) (output[1] * (imageSize - 1));
					// Use input values (of which there are between 1 and 3) to determine HSV values.
					double hue = mci.getCount(0) * stepSize;
					double light = function.getInputCount() >= 2 ? (0.3 + 0.7 * mci.getCount(1) * stepSize) : 1;
					double sat = function.getInputCount() >= 3 ? (0.3 + 0.7 * mci.getCount(2) * stepSize) : 1;
					g.setColor(Color.getHSBColor((float) hue, (float) sat, (float) light));
					g.fillRect(x, y, 1, 1);
				}
				File outputfile = new File(fileName + ".hsv_coord.png");
				try {
					ImageIO.write(image, "png", outputfile);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}

			if (function.getOutputCount() <= 3 && function.getInputCount() == 2) {
				BufferedImage image = new BufferedImage(imageSize, imageSize, BufferedImage.TYPE_3BYTE_BGR);
				Graphics2D g = image.createGraphics();
				g.setColor(Color.WHITE);
				g.fillRect(0, 0, imageSize, imageSize);
				int granularity = imageSize + 1;
				double stepSize = 1d / (granularity - 1); // Step size in unit-cube.

				// For each input value permutation.
				MultidimensionalCounter mc = new MultidimensionalCounter(ArrayUtil.newArray(function.getInputCount(), granularity));
				MultidimensionalCounter.Iterator mci = mc.iterator();
				double[] input = new double[function.getInputCount()];
				while (mci.hasNext()) {
					mci.next();
					// Set input values to function.
					for (int d = 0; d < function.getInputCount(); d++) {
						input[d] = inputValueRange.translateFromUnit(mci.getCount(d) * stepSize);
					}
					// Get output from function given input values.
					double[] output = transform(input, true);

					// Use output values (of which there are only two) to determine coordinates.
					int x = (int) (mci.getCount(0) * stepSize * (imageSize - 1));
					int y = (int) (mci.getCount(1) * stepSize * (imageSize - 1));
					// Use input values (of which there are between 1 and 3) to determine HSV values.
					double hue = output[0];
					double light = function.getOutputCount() >= 2 ? (0.3 + 0.7 * output[1]) : 1;
					double sat = function.getOutputCount() >= 3 ? (0.3 + 0.7 * output[2]) : 1;
					g.setColor(Color.getHSBColor((float) hue, (float) sat, (float) light));
					g.fillRect(x, y, 1, 1);
				}
				File outputfile = new File(fileName + ".coord_hsv.png");
				try {
					ImageIO.write(image, "png", outputfile);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

		@Override
		public String toString() {
			String out = "Type: " + type;
			out += "Input value range: " + inputValueRange;
			out += "\nOutput value range: " + outputValueRanges;
			out += "\nScale output enabled: " + (type.scaleOutput() ? "yes" : "no");
			out += "\n" + function.toString();
			return out;
		}
	}

	public enum TransformType {
		INPUT(true, true), OUTPUT(true, false), STATE(true, false);

		private boolean scaleOutput;
		private boolean ensureAllOutputSignCombinationsExist;

		private TransformType(boolean scaleOutput, boolean ensureAllOutputSignCombinationsExist) {
			this.scaleOutput = scaleOutput;
			this.ensureAllOutputSignCombinationsExist = ensureAllOutputSignCombinationsExist;
		}

		public boolean scaleOutput() {
			return scaleOutput;
		}

		public boolean ensureAllOutputSignCombinationsExist() {
			return ensureAllOutputSignCombinationsExist;
		}
	}
}
